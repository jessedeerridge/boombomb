<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ãƒ†ãƒ³ãƒ—ãƒ¬</title>
<style>
/* ï¼ˆä¸­ç•¥ãªã—ãƒ»ãƒ•ãƒ«ç‰ˆï¼‰ */
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee;}
h1{margin:0;font-size:18px;}
.small{font-size:12px;opacity:.75;}
.join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px;}
.join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
.btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
.btn.primary{background:#111;color:#fff;border-color:#111;}
.btn.ghost{background:transparent;}
.hidden{display:none;}
#lobby{padding:20px;border-top:1px solid #eee;}
.copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}
.seat-pop{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);background:orange;border:1px solid #eee;border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;}
.seat-pop.hidden{display:none;}
.seat-pop .row{display:flex;gap:8px;align-items:center;}
.seat-pop label{width:84px;font-size:13px;}
.seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
.tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
.tab.disabled::after{content:'âœ•';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
.tab.active{background:#111;color:#fff;border-color:#111;}

/* â˜… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å††é…ç½®ç”¨ */
.player-circle{
  position:relative;
  width:260px;
  height:260px;
  margin:20px auto 0;
  border-radius:50%;
  border:1px dashed #ddd;
  box-sizing:border-box;
}
.player-circle::before{
  content:''; /* ãƒ­ãƒ“ãƒ¼ç”¨ãªã®ã§ä¸­ã®æ–‡å­—ã¯æ¶ˆã™ */
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  font-size:11px;
  opacity:.45;
  pointer-events:none;
}
.player-tag{
  position:absolute;
  transform:translate(-50%,-50%);
  padding:4px 8px;
  border-radius:999px;
  background:#f8f8f8;
  border:1px solid #ddd;
  font-size:12px;
  white-space:nowrap;
}

/* â˜… ãƒãƒ¼ãƒ ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã¾ã‚ã‚Šã®ç‚¹ç·šå††ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼ä¸è¦ãªã‚‰ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã”ã¨å‰Šé™¤ï¼‰ */
.player-tag::before{
  content:'';
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:70px;      /* å††ã®å¤§ãã•ï¼šå¿…è¦ãªã‚‰ã“ã“ã‚’å¤‰ãˆã‚‹ */
  height:70px;     /* å††ã®å¤§ãã•ï¼šå¿…è¦ãªã‚‰ã“ã“ã‚’å¤‰ãˆã‚‹ */
  border-radius:50%;
  border:1px dashed rgba(0,0,0,.25);
  pointer-events:none;
  border:none;            /* â† ã“ã“ã ã‘å¤‰æ›´ï¼ˆã¾ãŸã¯å‰Šé™¤ï¼‰ */
}

.player-tag.me{
  background:#111;
  color:#fff;
  border-color:#111;
}

/* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ */
.player-tag .mini-hand{
  position:absolute;
  left:50%;
  top:100%;
  transform:translate(-50%,3px);
  width:60px;
  height:30px;
  pointer-events:none;
}
.player-tag .mini-card{
  position:absolute;
  left:50%;
  top:0;
  width:16px;
  height:22px;
  border-radius:4px;
  border:1px solid #bbb;
  background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
  font-size:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  transform-origin:bottom center;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
}

/* â˜… ãƒãƒ¼ãƒ ã‚¿ã‚°ã¾ã‚ã‚Šã®èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ï¼ˆå·¦å³ã§ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’å¤‰ãˆã‚‹ï¼‰ */
.attached-cube-row{
  position:absolute;
  top:50%;
  display:flex;
  align-items:center;
  gap:0;
}

/* ğŸ”¹ å††ã®å³å´ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨ï¼ˆä»Šã¾ã§ã¨åŒã˜ãå³å´ã«é‡ã­æ°—å‘³ï¼‰ */
.player-tag.side-right .attached-cube-row{
  left:100%;
  transform:translate(-20px,-50%);
}
.player-tag.side-right .attached-cube{
  margin-left:-50px;
}
.player-tag.side-right .attached-cube:first-child{
  margin-left:0;
}

/* ğŸ”¹ å††ã®å·¦å´ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨ï¼šãƒãƒ¼ãƒ ã‚¿ã‚°ã®ã€Œå·¦ã€ã« 1 å€‹ãšã¤ä¸¦ã¹ã‚‹ */
.player-tag.side-left .attached-cube-row{
  left:0;
  transform:translate(calc(-100% + 20px), -50%);
  gap:4px;
}
.player-tag.side-left .attached-cube{
  margin-left:-54px;
}

.attached-cube{
  width:72px;
  height:72px;
  flex:0 0 auto;
  cursor:grab;
  position:relative;
}

.attached-cube svg{
  width:100%;
  height:100%;
  display:block;
}
.attached-cube.dragging{
  cursor:grabbing;
}

/* æ‰‹æœ­ãƒ»ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ãƒ»æ¨ã¦æœ­ã‚«ãƒ¼ãƒ‰å…±é€šã®è¦‹ãŸç›® */
.my-card,
.used-card,
.discard-card-layer{
  width:60px;
  height:90px;
  border-radius:8px;
  border:1px solid #ddd;
  background:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:600;
  box-shadow:0 4px 12px rgba(0,0,0,.15);
  box-sizing:border-box;
  padding:6px;
}
.my-card{
  cursor:pointer;
  user-select:none;
}

/* ã‚«ãƒ¼ãƒ‰ä¸­èº«ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆãƒ©ãƒ™ãƒ«ï¼‹èª¬æ˜æ–‡ï¼‰ */
.card-face{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:4px;
  text-align:center;
}
.card-timing{
  padding:2px 8px;
  border-radius:999px;
  background:#111;
  color:#fff;
  font-size:8px;
  line-height:1.2;
}
.card-text{
  font-size:8px;
  line-height:1.4;
  color:#111;
}

.my-hand-wrapper{
  margin-top:16px;
  text-align:center;
}
.my-hand-title{
  font-size:12px;
  opacity:.7;
}
.my-hand{
  display:flex;
  justify-content:center;
  gap:8px;
  margin-top:6px;
  min-height:100px;
}

/* å±±æœ­ï¼‹æ¨ã¦æœ­ï¼‹ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ã®æ¨ªä¸¦ã³ */
.deck-row{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:40px;
  margin:8px auto 0;
}
.deck-pile,
.discard-pile,
.used-pile{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:4px;
  width:60px;
}
.deck-stack{
  position:relative;
  width:60px;
  height:90px;
}
.deck-card-layer{
  position:absolute;
  left:0;
  top:0;
  width:60px;
  height:90px;
  border-radius:8px;
  border:1px solid #ddd;
  background:linear-gradient(135deg,#1f2937,#4b5563);
  box-shadow:0 4px 12px rgba(0,0,0,.22);
  transform:translateY(var(--offset,0px));
}

/* æ¨ã¦æœ­ */
.discard-stack{
  position:relative;
  width:60px;
  height:90px;
}
.discard-card-layer{
  position:absolute;
  left:0;
  top:0;
  transform:translateY(var(--offset,0px));
}

/* ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ */
.used-cards-area{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:10px;
  margin:0;
  min-height:90px;
  width:60px;
}

/* å„ç¨®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ï¼ˆè¿½ã„å‡ºã—ç¢ºèªï¼‰ */
.dialog-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.35);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:300;
}
.dialog-backdrop.hidden{
  display:none;
}
.dialog-box{
  background:#fff;
  border-radius:12px;
  padding:16px 18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  max-width:320px;
  width:calc(100% - 40px);
}
.dialog-box p{
  margin:0 0 12px;
  font-size:14px;
  line-height:1.6;
}
.dialog-buttons{
  display:flex;
  justify-content:flex-end;
  gap:8px;
}

/* æ‰‹æœ­ä½¿ç”¨ãƒãƒƒãƒ—ï¼ˆã€Œä½¿ã†ã€ãƒœã‚¿ãƒ³ã ã‘ï¼‰ */
.use-card-pop{
  position:fixed;
  padding:0;
  border:none;
  background:transparent;
  box-shadow:none;
  display:block;
  z-index:270;
}
.use-card-pop.hidden{
  display:none;
}
.use-card-pop .btn{
  padding:4px 14px;
  font-size:12px;
}

/* ãƒ›ã‚¹ãƒˆç”¨ è¨­å®šãƒœã‚¿ãƒ³ï¼ˆå³ä¸‹ï¼‰ */
.host-settings-btn{
  position:fixed;
  right:16px;
  bottom:16px;
  width:44px;
  height:44px;
  border-radius:50%;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 8px 20px rgba(0,0,0,.18);
  display:none;
  align-items:center;
  justify-content:center;
  font-size:22px;
  cursor:pointer;
  z-index:230;
}
.host-settings-btn.visible{
  display:flex;
}

/* ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒƒãƒ—ï¼ˆå³ä¸‹ï¼‰ */
.start-pop{
  position:fixed;
  right:16px;
  bottom:72px;
  background:#fff;
  border:1px solid #ddd;
  border-radius:12px;
  box-shadow:0 12px 28px rgba(0,0,0,.16);
  padding:10px 12px;
  z-index:240;
  min-width:240px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.start-pop.hidden{
  display:none;
}
.start-pop-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
}
.start-pop-title{
  font-size:14px;
  font-weight:600;
}
.start-pop-main{
  font-size:13px;
  line-height:1.5;
}
.start-pop-actions{
  display:flex;
  justify-content:flex-end;
  gap:8px;
  margin-top:4px;
}

/* ã‚µã‚¤ã‚³ãƒ­ã‚¨ãƒªã‚¢ï¼ˆå††ã®ä¸­ï¼‰ */
.dice-area{
  position:absolute;
  left:50%;
  top:50%;
  width:260px;
  height:260px;
  transform:translate(-50%,-50%);
  border-radius:50%;
  background:transparent;
  border:none;
  box-shadow:none;
  pointer-events:none;
}
.dice{
  position:absolute;
  left:50%;
  top:50%;
  width:46px;
  height:46px;
  border-radius:10px;
  border:1px solid #ddd;
  background:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 4px 12px rgba(0,0,0,.18);
  cursor:grab;
  touch-action:none;
  pointer-events:auto;
  --tx:0px;
  --ty:0px;
  --rot:0deg;
  transform:translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) rotate(var(--rot));
  transition:transform .14s ease-out, box-shadow .14s ease-out;
}
.dice.dragging{
  cursor:grabbing;
  box-shadow:0 8px 20px rgba(0,0,0,.28);
  transition:none;
}
.dice.rolling{
  transition:transform .5s cubic-bezier(.22,.84,.44,1.1);
}
.dice.dice-locked{
  pointer-events:none;
}
.dice-face{
  position:relative;
  width:100%;
  height:100%;
}
.pip{
  position:absolute;
  width:9px;
  height:9px;
  border-radius:50%;
  background:#111;
  opacity:0;
  transition:opacity .12s;
  transform:translate(-50%, -50%);
}
.pip.red{
  background:#dc2626;
}
.pip.pos0{ left:25%; top:25%; }
.pip.pos1{ left:75%; top:25%; }
.pip.pos2{ left:25%; top:50%; }
.pip.pos3{ left:50%; top:50%; }
.pip.pos4{ left:75%; top:50%; }
.pip.pos5{ left:25%; top:75%; }
.pip.pos6{ left:75%; top:75%; }

/* å¤§å¤–ã®å†† */
.player-circle::after{
  content:'';
  position:absolute;
  left:50%;
  top:50%;
  width:500px;
  height:500px;
  transform:translate(-50%,-50%);
  border-radius:50%;
  border:none;
  box-sizing:border-box;
  pointer-events:none;
}

/* ãƒ­ãƒ“ãƒ¼ã®è¦‹ãŸç›®èª¿æ•´ */
.player-circle{border:none;}
.player-circle::before{content:'';}
.my-hand-title{display:none;}
#roomInfoLobby,
#lobby h2,
#lobby p {display:none;}
#lobby.entered {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:calc(100vh - 60px);
}

/* ã‚µã‚¤ã‚³ãƒ­å‡ºç›®èª¿æ•´ãƒãƒƒãƒ— */
.dice-adjust-pop{
  position:fixed;
  padding:6px 8px;
  border-radius:999px;
  background:#fff;
  border:1px solid #ddd;
  box-shadow:0 8px 18px rgba(0,0,0,.2);
  display:flex;
  gap:4px;
  z-index:260;
}
.dice-adjust-pop.hidden{
  display:none;
}
.dice-adjust-pop button{
  min-width:32px;
  padding:2px 6px;
  border-radius:999px;
  border:1px solid #ddd;
  background:#f8f8f8;
  font-size:12px;
  cursor:pointer;
}

/* â–·ãƒœã‚¿ãƒ³ï¼ˆã‚¿ãƒ¼ãƒ³é€ã‚Šï¼‰ */
.turn-next-btn{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  width:64px;
  height:64px;
  padding:0;
  border-radius:50%;
  border:1px solid #111;
  background:#111;
  color:#fff;
  font-size:32px;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  box-shadow:0 8px 20px rgba(0,0,0,.3);
  z-index:235;
}
.turn-next-btn.hidden{
  display:none;
}

/* ã€Œâ—‹â—‹ã®ã‚¿ãƒ¼ãƒ³ã€ãƒãƒŠãƒ¼ */
.turn-banner{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-150%, -50%);
  background:#111;
  color:#fff;
  padding:10px 24px;
  border-radius:999px;
  font-size:20px;
  font-weight:700;
  box-shadow:0 10px 24px rgba(0,0,0,.3);
  white-space:nowrap;
  z-index:260;
  transition:transform .6s cubic-bezier(.22,.84,.44,1);
}
.turn-banner.turn-banner-center{
  transform:translate(-50%, -50%);
}
.turn-banner.turn-banner-right{
  transform:translate(150%, -50%);
}

/* â–·é•·æŠ¼ã—ãƒãƒƒãƒ—ï¼ˆå‚åŠ è€…ä¸€è¦§ï¼‰ */
.turn-select-pop{
  position:fixed;
  left:50%;
  bottom:90px;
  transform:translateX(-50%);
  background:#fff;
  border:1px solid #ddd;
  border-radius:12px;
  box-shadow:0 12px 28px rgba(0,0,0,.22);
  padding:10px 12px;
  z-index:250;
  min-width:220px;
  max-width:280px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.turn-select-pop.hidden{
  display:none;
}
.turn-select-header{
  font-size:13px;
  font-weight:600;
}
.turn-select-list{
  display:flex;
  flex-direction:column;
  gap:6px;
  max-height:200px;
  overflow-y:auto;
}
.turn-select-list .btn{
  width:100%;
  justify-content:flex-start;
  font-size:13px;
  padding:4px 8px;
}

/* â˜…â˜…â˜… ã“ã“ã‹ã‚‰å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–ç”¨ â˜…â˜…â˜… */
.cube-circle{
  position:fixed;
  right:16px;
  top:72px;
  width:220px;
  height:220px;
  border-radius:50%;
  background:transparent; /* å††ã¯ä¸å¯è¦– */
  border:none;
  pointer-events:none;
  z-index:210;
}
.cube-piece{
  position:absolute;
  left:50%;
  top:50%;
  width:72px;
  height:72px;
  --tx:0px;
  --ty:0px;
  transform:translate(calc(-50% + var(--tx)), calc(-50% + var(--ty)));
  cursor:grab;
  touch-action:none;
  pointer-events:auto;
}
.cube-piece.dragging{
  cursor:grabbing;
}
.cube-piece svg{
  width:100%;
  height:100%;
  display:block;
}
/* â˜…â˜…â˜… å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–ç”¨ ã“ã“ã¾ã§ â˜…â˜…â˜… */
</style>
</head>
<body>

<header>
  <h1>ãƒ†ãƒ³ãƒ—ãƒ¬</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">ãƒªãƒ³ã‚¯ã‚³ãƒ”ãƒ¼</button>
  </div>
</header>

<main>
<div class="join-box" id="joinBox">
  <input id="userName" placeholder="åå‰ï¼ˆ4æ–‡å­—ä»¥å†…ï¼‰" maxlength="4" />
  <input id="roomCode" placeholder="ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ï¼ˆæœªå…¥åŠ›ã§è‡ªå‹•ç”Ÿæˆï¼‰" maxlength="12" />
  <button class="btn primary" id="btnJoin">å…¥å®¤</button>
</div>

<div id="lobby" class="hidden">
  <h2>ãƒ­ãƒ“ãƒ¼</h2>
  <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
  <p>ã“ã“ã«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚„æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>

  <!-- å±±æœ­ï¼‹æ¨ã¦æœ­ï¼‹ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ -->
  <div class="deck-row">
    <div class="deck-pile">
      <div id="deckStack" class="deck-stack"></div>
    </div>
    <div class="discard-pile">
      <div id="discardStack" class="discard-stack"></div>
    </div>
    <div class="used-pile">
      <div id="usedCardsArea" class="used-cards-area"></div>
    </div>
  </div>

  <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å†† -->
  <div id="playerCircle" class="player-circle"></div>

  <!-- è‡ªåˆ†ã®æ‰‹æœ­ -->
  <div class="my-hand-wrapper">
    <div class="my-hand-title">è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰</div>
    <div id="myHand" class="my-hand"></div>
  </div>
</div>
</main>

<!-- ç€å¸­ãƒãƒƒãƒ— -->
<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>å¸­ã‚’é¸æŠ</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">è¦³æˆ¦</button>
  </div>
</div>

<!-- è¿½ã„å‡ºã—ç¢ºèªãƒãƒƒãƒ— -->
<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">æ—¢å­˜ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã„å‡ºã—ã¦ã€ç€å¸­ã—ã¾ã™ã‹ï¼Ÿ</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">ã„ã„ãˆ</button>
      <button class="btn primary" id="btnKickYes">ã¯ã„</button>
    </div>
  </div>
</div>

<!-- æ‰‹æœ­ä½¿ç”¨ãƒãƒƒãƒ—ï¼ˆã‚¯ãƒªãƒƒã‚¯ä½ç½®ã«ã€Œä½¿ã†ã€ã ã‘ï¼‰ -->
<div id="useCardDialog" class="use-card-pop hidden">
  <button class="btn primary" id="btnUseCardYes">ä½¿ã†</button>
</div>

<!-- ã‚µã‚¤ã‚³ãƒ­å‡ºç›®èª¿æ•´ãƒãƒƒãƒ— -->
<div id="diceAdjustPop" class="dice-adjust-pop hidden">
  <button data-value="1">1</button>
  <button data-value="2">2</button>
  <button data-value="3">3</button>
  <button data-value="4">4</button>
  <button data-value="5">5</button>
  <button data-value="6">6</button>
</div>

<!-- ãƒ›ã‚¹ãƒˆè¨­å®šãƒœã‚¿ãƒ³ -->
<button id="hostSettingsBtn" class="host-settings-btn" title="è¨­å®š">âš™</button>

<!-- ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒƒãƒ— -->
<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">Ã—</button>
  </div>
  <div class="start-pop-main">
    æº–å‚™ãŒã§ããŸã‚‰ã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚<br>
    æŠ¼ã™ã¨å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚«ãƒ¼ãƒ‰ãŒ5æšãšã¤é…ã‚‰ã‚Œã¾ã™ã€‚
  </div>
  <div class="start-pop-actions">
    <button id="btnGameStart" class="btn primary">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>
</div>

<!-- â–·ãƒœã‚¿ãƒ³ -->
<button id="turnNextBtn" class="turn-next-btn hidden">â–·</button>

<!-- ã‚¿ãƒ¼ãƒ³ãƒãƒŠãƒ¼ -->
<div id="turnBanner" class="turn-banner hidden"></div>

<!-- â–·é•·æŠ¼ã—ï¼šå‚åŠ è€…ä¸€è¦§ -->
<div id="turnSelectPop" class="turn-select-pop hidden">
  <div class="turn-select-header">ã‚¿ãƒ¼ãƒ³ã«ã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é¸æŠ</div>
  <div id="turnSelectList" class="turn-select-list"></div>
</div>

<!-- â˜…â˜…â˜… ç«‹æ–¹ä½“SVGãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå„ã‚­ãƒ¥ãƒ¼ãƒ–ã§è¤‡è£½ã—ã¦ä½¿ç”¨ï¼‰ â˜…â˜…â˜… -->
<template id="cubeTemplate">
  <svg viewBox="0 0 400 320">
    <defs>
      <!-- å‰é¢ -->
      <radialGradient id="g_front" cx="50%" cy="50%" r="70%">
        <stop offset="0%" stop-color="#d02030" stop-opacity="0.35"/>
        <stop offset="70%" stop-color="#b00020" stop-opacity="0.70"/>
        <stop offset="100%" stop-color="#600010" stop-opacity="0.85"/>
      </radialGradient>
      <!-- å³å´é¢ -->
      <radialGradient id="g_side" cx="40%" cy="40%" r="90%">
        <stop offset="0%" stop-color="#d02030" stop-opacity="0.22"/>
        <stop offset="60%" stop-color="#b00020" stop-opacity="0.55"/>
        <stop offset="100%" stop-color="#600010" stop-opacity="0.75"/>
      </radialGradient>
      <!-- ä¸Šé¢ -->
      <radialGradient id="g_top" cx="60%" cy="60%" r="90%">
        <stop offset="0%" stop-color="#d02030" stop-opacity="0.15"/>
        <stop offset="60%" stop-color="#b00020" stop-opacity="0.43"/>
        <stop offset="100%" stop-color="#600010" stop-opacity="0.68"/>
      </radialGradient>
      <!-- èƒŒé¢ç”¨ï¼šå‰ã‚ˆã‚Šè–„ã„ -->
      <radialGradient id="g_back" cx="50%" cy="50%" r="70%">
        <stop offset="0%" stop-color="#d02030" stop-opacity="0.10"/>
        <stop offset="70%" stop-color="#b00020" stop-opacity="0.30"/>
        <stop offset="100%" stop-color="#600010" stop-opacity="0.50"/>
      </radialGradient>
      <!-- ç·šã‚’ã¼ã‹ã™ -->
      <filter id="blurEdges">
        <feGaussianBlur in="SourceGraphic" stdDeviation="1.0" result="blur" />
        <feComposite in="blur" in2="SourceGraphic" operator="in" />
      </filter>

      <!-- â˜… å˜ç‹¬ãƒ—ãƒ¬ãƒ¼ãƒˆæŠ½å‡ºç”¨ãƒã‚¹ã‚¯ç¾¤ -->
      <!-- ãƒ‘ã‚¹å®šç¾©ï¼ˆä½¿ã„å›ã™ç”¨ï¼‰ -->
      <g id="shape_back">
        <path d=" M178,100 L242,100 Q250,100 250,108 L250,172 Q250,180 242,180 L178,180 Q170,180 170,172 L170,108 Q170,100 178,100 Z "/>
      </g>
      <g id="shape_left">
        <path d=" M136.4,125.2 L163.6,104.8 Q170,100 170,108 L170,172 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 130,202 L130,138 Q130,130 136.4,125.2 Z "/>
      </g>
      <g id="shape_bottom">
        <path d=" M138,210 L202,210 Q210,210 216.4,205.2 L243.6,184.8 Q250,180 242,180 L178,180 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 138,210 Z "/>
      </g>
      <g id="shape_front">
        <path d=" M138,130 L202,130 Q210,130 210,138 L210,202 Q210,210 202,210 L138,210 Q130,210 130,202 L130,138 Q130,130 138,130 Z "/>
      </g>
      <g id="shape_right">
        <path d=" M216.4,125.2 L243.6,104.8 Q250,100 250,108 L250,172 Q250,180 243.6,184.8 L216.4,205.2 Q210,210 210,202 L210,138 Q210,130 216.4,125.2 Z "/>
      </g>
      <g id="shape_top">
        <path d=" M138,130 L202,130 Q210,130 216.4,125.2 L243.6,104.8 Q250,100 242,100 L178,100 Q170,100 163.6,104.8 L136.4,125.2 Q130,130 138,130 Z "/>
      </g>

      <!-- å…±é€š: å…¨é¢é»’èƒŒæ™¯ -->
      <rect id="mask_bg" x="0" y="0" width="400" height="320" fill="black"/>

      <!-- front å˜ç‹¬ -->
      <mask id="m_frontOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_front" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_right" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
      <!-- right å˜ç‹¬ -->
      <mask id="m_rightOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_right" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
      <!-- top å˜ç‹¬ -->
      <mask id="m_topOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_top" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_right" fill="black"/>
      </mask>
      <!-- left å˜ç‹¬ -->
      <mask id="m_leftOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_left" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_right" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
      <!-- back å˜ç‹¬ -->
      <mask id="m_backOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_back" fill="white"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_right" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
      <!-- bottom å˜ç‹¬ -->
      <mask id="m_bottomOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_bottom" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_right" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
    </defs>

    <!-- èƒŒé¢ -->
    <path d=" M178,100 L242,100 Q250,100 250,108 L250,172 Q250,180 242,180 L178,180 Q170,180 170,172 L170,108 Q170,100 178,100 Z " fill="url(#g_back)" />
    <!-- å·¦å´é¢ -->
    <path d=" M136.4,125.2 L163.6,104.8 Q170,100 170,108 L170,172 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 130,202 L130,138 Q130,130 136.4,125.2 Z " fill="url(#g_back)" />
    <!-- åº•é¢ -->
    <path d=" M138,210 L202,210 Q210,210 216.4,205.2 L243.6,184.8 Q250,180 242,180 L178,180 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 138,210 Z " fill="url(#g_back)" />
    <!-- å‰é¢ -->
    <path d=" M138,130 L202,130 Q210,130 210,138 L210,202 Q210,210 202,210 L138,210 Q130,210 130,202 L130,138 Q130,130 138,130 Z " fill="url(#g_front)" />
    <!-- å³å´é¢ -->
    <path d=" M216.4,125.2 L243.6,104.8 Q250,100 250,108 L250,172 Q250,180 243.6,184.8 L216.4,205.2 Q210,210 210,202 L210,138 Q210,130 216.4,125.2 Z " fill="url(#g_side)" />
    <!-- ä¸Šé¢ -->
    <path d=" M138,130 L202,130 Q210,130 216.4,125.2 L243.6,104.8 Q250,100 242,100 L178,100 Q170,100 163.6,104.8 L136.4,125.2 Q130,130 138,130 Z " fill="url(#g_top)" />

    <!-- å†…éƒ¨ç·š -->
    <g stroke="#700010" stroke-linejoin="round" filter="url(#blurEdges)">
      <line x1="170" y1="100" x2="170" y2="180" stroke-width="1.4" stroke-opacity="0.30"/>
      <line x1="170" y1="100" x2="250" y2="100" stroke-width="1.4" stroke-opacity="0.30"/>
      <line x1="170" y1="180" x2="250" y2="180" stroke-width="1.4" stroke-opacity="0.30"/>
    </g>

    <!-- å˜ç‹¬ãƒ—ãƒ¬ãƒ¼ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
    <g fill="#600010" fill-opacity="0.35">
      <path d=" M138,130 L202,130 Q210,130 210,138 L210,202 Q210,210 202,210 L138,210 Q130,210 130,202 L130,138 Q130,130 138,130 Z " mask="url(#m_frontOnly)"/>
      <path d=" M216.4,125.2 L243.6,104.8 Q250,100 250,108 L250,172 Q250,180 243.6,184.8 L216.4,205.2 Q210,210 210,202 L210,138 Q210,130 216.4,125.2 Z " mask="url(#m_rightOnly)"/>
      <path d=" M138,130 L202,130 Q210,130 216.4,125.2 L243.6,104.8 Q250,100 242,100 L178,100 Q170,100 163.6,104.8 L136.4,125.2 Q130,130 138,130 Z " mask="url(#m_topOnly)"/>
      <path d=" M136.4,125.2 L163.6,104.8 Q170,100 170,108 L170,172 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 130,202 L130,138 Q130,130 136.4,125.2 Z " mask="url(#m_leftOnly)"/>
      <path d=" M178,100 L242,100 Q250,100 250,108 L250,172 Q250,180 242,180 L178,180 Q170,180 170,172 L170,108 Q170,100 178,100 Z " mask="url(#m_backOnly)"/>
      <path d=" M138,210 L202,210 Q210,210 216.4,205.2 L243.6,184.8 Q250,180 242,180 L178,180 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 138,210 Z " mask="url(#m_bottomOnly)"/>
    </g>
  </svg>
</template>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

/* â˜… ã‚«ãƒ¼ãƒ‰å®šç¾©ï¼ˆå„2æšãšã¤ï¼‰ */
const CARD_DEFS = [
  // â‘  ã„ã¤ã§ã‚‚ä½¿ãˆã‚‹
  { id:'ANY_SKIP_NEXT',        timing:'ã„ã¤ã§ã‚‚', text:'1äººæ‰‹ç•ªã‚’é£›ã°ã™' },
  { id:'ANY_SKIP_TO_PLAYER',   timing:'ã„ã¤ã§ã‚‚', text:'å¥½ããªäººã¾ã§æ‰‹ç•ªã‚’é£›ã°ã™' },
  { id:'ANY_DICE_MINUS2',      timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’-2ã™ã‚‹(1,2ã«ä½¿ãˆãªã„)' },
  { id:'ANY_DICE_MINUS1',      timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’-1ã™ã‚‹' },
  { id:'ANY_DICE_PLUS1',       timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’+1ã™ã‚‹' },
  { id:'ANY_DICE_PLUS2',       timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’+2ã™ã‚‹(5,6ã«ä½¿ãˆãªã„)' },
  { id:'ANY_ADD_DICE1_START',  timing:'ã„ã¤ã§ã‚‚', text:'æŒ¯ã‚‹å‰ã«ãƒ€ã‚¤ã‚¹ã‚’1ã¤å¢—ã‚„ã™' },
  { id:'ANY_ADD_DICE2_START',  timing:'ã„ã¤ã§ã‚‚', text:'æŒ¯ã‚‹å‰ã«ãƒ€ã‚¤ã‚¹ã‚’2ã¤å¢—ã‚„ã™' },
  { id:'ANY_HEAL1',            timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’1å›å¾©ã™ã‚‹' },
  { id:'ANY_SET_DICE_ANY',     timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’ä»»æ„ã®ç›®ã«å¤‰ãˆã‚‹' },
  { id:'ANY_REROLL_1_OR_2',    timing:'ã„ã¤ã§ã‚‚', text:'ãƒ€ã‚¤ã‚¹ã‚’1ï½2å€‹ãµã‚ŠãªãŠã™' },
  { id:'ANY_EXPLOSION_PLUS1',  timing:'ã„ã¤ã§ã‚‚', text:'çˆ†ç™ºæ™‚ã«å…¨ã¦ã®çˆ†ç™ºãƒ€ãƒ¡ãƒ¼ã‚¸+1' },
  { id:'ANY_BOTH_NEIGHBOR_B1', timing:'ã„ã¤ã§ã‚‚', text:'èª°ã‹ãŒçˆ†ç™ºã—ãŸæ™‚ã€ä¸¡éš£ã‚‚çˆ†ç™ºã™ã‚‹' },
  { id:'ANY_SELF_EXPLOSION_B1',timing:'ã„ã¤ã§ã‚‚', text:'è‡ªåˆ†ãŒçˆ†ç™ºã—ãŸæ™‚ã€ã‚‚ã†ä¸€äººé¸ã‚“ã§çˆ†ç™º' },
  { id:'ANY_RESET_DICE_8',     timing:'ã„ã¤ã§ã‚‚', text:'ãƒ€ã‚¤ã‚¹ã®æ•°ã‚’8ã¤ã«ã‚‚ã©ã™' },
  { id:'ANY_START_DICE_MINUS1',timing:'ã„ã¤ã§ã‚‚', text:'æŒ¯ã‚‹å‰ã«ãƒ€ã‚¤ã‚¹ã‚’1ã¤é™¤ã' },
  { id:'ANY_START_DICE_MINUS2',timing:'ã„ã¤ã§ã‚‚', text:'æŒ¯ã‚‹å‰ã«ãƒ€ã‚¤ã‚¹ã‚’2ã¤é™¤ã' },

  // â‘¡ è‡ªåˆ†ã®ç•ªã§ä½¿ãˆã‚‹
  { id:'TURN_DRAW2',                 timing:'æ‰‹ç•ªã§', text:'ã‚«ãƒ¼ãƒ‰ã‚’2æšã²ã' },
  { id:'TURN_PEEK_ROLE',             timing:'æ‰‹ç•ªã§', text:'ä»»æ„ã®1äººã‚’é¸ã³ã€æ­£ä½“ã‚’è¦‹ã‚‹' },
  { id:'TURN_SHOW_ROLE_HEAL1_EXILE', timing:'æ‰‹ç•ªã§', text:'1äººã«æ­£ä½“ã‚’è¦‹ã›ã¦1å›å¾©ï¼Š' },
  { id:'TURN_DRAW2_KEEP_GIVE1',      timing:'æ‰‹ç•ªã§', text:'ã‚«ãƒ¼ãƒ‰ã‚’2æšã²ãã€ã†ã¡1æšã¯èª°ã‹ã«æ¸¡ã™' },
  { id:'TURN_SHUFFLE3_ROLES_EXILE',  timing:'æ‰‹ç•ªã§', text:'3äººé¸ã³ã€æ­£ä½“ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼Š' },
  { id:'TURN_SELF_HEAL1_ALL_DRAW1',  timing:'æ‰‹ç•ªã§', text:'1å›å¾©ã—ãŸå¾Œã€å…¨å“¡ã‚«ãƒ¼ãƒ‰ã‚’1æšã²ã' },
  { id:'TURN_SHOW_ROLES_MUTUAL_EXILE',timing:'æ‰‹ç•ªã§', text:'æ­£ä½“ã‚’è¦‹ã›ã‚ã†ï¼Š' }
];

// å„ã‚«ãƒ¼ãƒ‰2æšãšã¤ã®å±±æœ­
const CARD_POOL = CARD_DEFS.flatMap(def => [def.id, def.id]);

// å±±æœ­åˆè¨ˆæšæ•°ï¼ˆãƒ‡ãƒƒã‚­è¡¨ç¤ºç”¨ï¼‰
const DECK_TOTAL = CARD_POOL.length;

// ã‚«ãƒ¼ãƒ‰å®šç¾©å–å¾—
function getCardDef(cardId){
  return CARD_DEFS.find(c => c.id === cardId) || null;
}

// ã‚«ãƒ¼ãƒ‰ã®è¦‹ãŸç›®ï¼ˆçœŸã‚“ä¸­ã¡ã‚‡ã£ã¨ä¸‹ã®ãƒ©ãƒ™ãƒ«ï¼‹ãã®ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆï¼‰
function createCardFace(cardId){
  const def = getCardDef(cardId);
  const wrap = document.createElement('div');
  wrap.className = 'card-face';

  if(def){
    const timing = document.createElement('div');
    timing.className = 'card-timing';
    timing.textContent = def.timing;

    const body = document.createElement('div');
    body.className = 'card-text';
    body.textContent = def.text;

    wrap.appendChild(timing);
    wrap.appendChild(body);
  }else{
    wrap.textContent = cardId ?? '';
  }
  return wrap;
}

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  usedCards: [],
  discardPile: [],
  currentTurnSeat: null
};

const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
const usedCardsArea = document.getElementById('usedCardsArea');
const deckStackEl = document.getElementById('deckStack');
const discardStackEl = document.getElementById('discardStack');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');

const useCardDialog = document.getElementById('useCardDialog');
const btnUseCardYes = document.getElementById('btnUseCardYes');

const diceAdjustPop = document.getElementById('diceAdjustPop');

const turnNextBtn = document.getElementById('turnNextBtn');
const turnBanner = document.getElementById('turnBanner');

const turnSelectPop = document.getElementById('turnSelectPop');
const turnSelectList = document.getElementById('turnSelectList');

/* â˜… ç«‹æ–¹ä½“ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‚ç…§ */
const cubeTemplate = document.getElementById('cubeTemplate');

let pendingSeatIndexToSteal = null;
let pendingPlayerNameToSteal = null;
let pendingSeatPlayerIdToSteal = null;

let isRenderingSeatTabs = false;
let latestPlayers = [];

let pendingUseCardIndex = null;
let pendingUseCardValue = null;

let isMovingUsedCardToDiscard = false;

let diceArea = null;
let draggingDie = null;
let dragPointerId = null;
let dragStartX = 0;
let dragStartY = 0;
let startTx = 0;
let startTy = 0;
let triggeredDiceThisDrag = null;
let allDiceRolledThisDrag = false;

let longPressTimer = null;
let longPressTriggered = false;
const LONG_PRESS_MS = 400;
const LONG_PRESS_MOVE_TOL = 6;

let turnBtnLongPressTimer = null;
let turnBtnLongPressTriggered = false;
let turnBtnPointerId = null;
let turnBtnDownX = 0;
let turnBtnDownY = 0;
let suppressTurnClick = false;

const INNER_RADIUS = 110 - 24;
const OUTER_RADIUS = 250;

const DICE_CONTACT_DIST = 55;
const DICE_COLLIDE_DIST = 63;

let diceLocked = false;
let turnBannerRunning = false;

/* â˜…â˜…â˜… å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–ç”¨ã®å®šæ•°ãƒ»å¤‰æ•° â˜…â˜…â˜… */
const CUBE_INNER_RADIUS = 80;
const CUBE_COLLIDE_DIST = 30;

// â˜… è¿½åŠ ï¼šã‚­ãƒ¥ãƒ¼ãƒ–ãŒå††ã®ä¸­ã‹ã©ã†ã‹åˆ¤å®š
function isInsideCubeRadius(x, y){
  return Math.hypot(x, y) <= CUBE_INNER_RADIUS;
}

let cubeArea = null;
let draggingCube = null;
let cubePointerId = null;
let cubeStartX = 0;
let cubeStartY = 0;
let cubeStartTx = 0;
let cubeStartTy = 0;

/* DBã‹ã‚‰ã®æœ€æ–°ã‚­ãƒ¥ãƒ¼ãƒ–çŠ¶æ…‹ã‚’ä¿æŒï¼ˆãƒãƒ¼ãƒ ã‚¿ã‚°å´ã§ã‚‚ä½¿ã†ï¼‰ */
let latestCubeData = {};

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ã«ä¸¦ã‚“ã§ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã®ãƒ‰ãƒ©ãƒƒã‚°ç”¨ */
let attachedDragCube = null;
let attachedDragPointerId = null;
let attachedDragStartX = 0;
let attachedDragStartY = 0;
let attachedDragSeatIndex = null;
let attachedDragCubeId = null;
/* â˜…â˜…â˜… ã“ã“ã¾ã§ â˜…â˜…â˜… */

function clearLongPressTimer(){
  if(longPressTimer){
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
}
function clearTurnBtnLongPressTimer(){
  if(turnBtnLongPressTimer){
    clearTimeout(turnBtnLongPressTimer);
    turnBtnLongPressTimer = null;
  }
}

function canTriggerContactRoll(){
  return !(state.usedCards && state.usedCards.length > 0);
}

function setDiceLocked(flag){
  diceLocked = flag;
  if(diceArea){
    const diceEls = diceArea.querySelectorAll('.dice');
    diceEls.forEach(d => {
      if(flag) d.classList.add('dice-locked');
      else d.classList.remove('dice-locked');
    });
  }
}

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? 'ï¼ˆãƒ›ã‚¹ãƒˆï¼‰' : '';
  const infoText = `ãƒ«ãƒ¼ãƒ : ${state.roomCode}, åå‰: ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
    if (turnNextBtn) turnNextBtn.classList.remove('hidden');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
    if (turnNextBtn) turnNextBtn.classList.add('hidden');
  }
}

function renderDeckStatus(){
  if (!deckStackEl) return;

  const handsCount = Object.values(state.hands || {}).reduce((sum, hand) => {
    if (hand && Array.isArray(hand.cards)) {
      return sum + hand.cards.length;
    }
    return sum;
  }, 0);

  const usedCount = state.usedCards ? state.usedCards.length : 0;
  const discardCount = state.discardPile ? state.discardPile.length : 0;

  let remain = DECK_TOTAL - handsCount - usedCount - discardCount;
  if (remain < 0) remain = 0;

  deckStackEl.innerHTML = '';

  let layers = 0;
  if (remain > 0) {
    const maxLayers = 8;
    const step = DECK_TOTAL / maxLayers;
    layers = Math.ceil(remain / step);
    if (layers < 1) layers = 1;
    if (layers > maxLayers) layers = maxLayers;
  }

  for (let i = 0; i < layers; i++) {
    const card = document.createElement('div');
    card.className = 'deck-card-layer';
    card.style.setProperty('--offset', `${-i * 2}px`);
    card.style.zIndex = String(10 + i);
    deckStackEl.appendChild(card);
  }
}

function renderDiscardPile(){
  if (!discardStackEl) return;
  discardStackEl.innerHTML = '';

  const cards = state.discardPile || [];
  const count = cards.length;
  if (!count) return;

  const maxLayers = 8;
  const layers = Math.min(maxLayers, count);

  for (let i = 0; i < layers - 1; i++) {
    const card = document.createElement('div');
    card.className = 'discard-card-layer';
    card.style.setProperty('--offset', `${-i * 2}px`);
    card.style.zIndex = String(10 + i);
    discardStackEl.appendChild(card);
  }

  const top = cards[count - 1];
  const topIndex = layers - 1 >= 0 ? layers - 1 : 0;
  const topCard = document.createElement('div');
  topCard.className = 'discard-card-layer';
  topCard.style.setProperty('--offset', `${-topIndex * 2}px`);
  topCard.style.zIndex = String(10 + topIndex);

  if (top && top.value != null){
    topCard.appendChild(createCardFace(top.value));
  }
  discardStackEl.appendChild(topCard);
}

function subscribeHostState(){
  if (!state.roomCode) return;
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
  });
}

function subscribeHands(){
  if (!state.roomCode) return;
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}

function subscribeUsedCards(){
  if (!state.roomCode) return;
  const usedRef = ref(db, `rooms/${state.roomCode}/usedCards`);
  onValue(usedRef, snap => {
    const arr = snap.val() || [];
    state.usedCards = Array.isArray(arr) ? arr : [];
    renderUsedCards();
  });
}

function subscribeDiscardPile(){
  if (!state.roomCode) return;
  const discRef = ref(db, `rooms/${state.roomCode}/discardPile`);
  onValue(discRef, snap => {
    const arr = snap.val() || [];
    state.discardPile = Array.isArray(arr) ? arr : [];
    renderDiscardPile();
    renderDeckStatus();
  });
}

function subscribeGameStarted(){
  if (!state.roomCode) return;
  const gameRef = ref(db, `rooms/${state.roomCode}/gameStarted`);
  onValue(gameRef, snap => {
    const v = snap.val();
    if (v) {
      ensureDiceArea();
      ensureCubeArea();
    }
  });
}

function subscribeTurnState(){
  if(!state.roomCode) return;
  const tRef = ref(db, `rooms/${state.roomCode}/turnState`);
  onValue(tRef, snap => {
    const v = snap.val();
    if(!v || !v.playerName) return;
    state.currentTurnSeat = v.seatIndex ?? null;
    playTurnBanner(v.playerName);
  });
}

function renderMyHand(){
  myHandEl.innerHTML = '';
  const myId = state.userId;
  const handData = state.hands[myId];
  if (!handData || !Array.isArray(handData.cards)) return;

  handData.cards.forEach((cardId, idx) => {
    const card = document.createElement('div');
    card.className = 'my-card';
    card.dataset.index = String(idx);
    card.dataset.value = String(cardId);
    card.appendChild(createCardFace(cardId));
    card.addEventListener('click', onMyCardClick);
    myHandEl.appendChild(card);
  });
}

function renderUsedCards(){
  usedCardsArea.innerHTML = '';

  const arr = state.usedCards || [];
  let cardToShow = null;

  if (arr.length) {
    const lastUsed = arr[arr.length - 1];

    const disc = state.discardPile || [];
    const topDiscard = disc.length ? disc[disc.length - 1] : null;

    if (
      topDiscard &&
      lastUsed &&
      topDiscard.value === lastUsed.value &&
      topDiscard.ownerId === lastUsed.ownerId &&
      topDiscard.usedAt === lastUsed.usedAt
    ) {
      cardToShow = null;
    } else {
      cardToShow = lastUsed;
    }
  }

  if (cardToShow) {
    const card = document.createElement('div');
    card.className = 'used-card';
    card.appendChild(createCardFace(cardToShow.value));
    card.addEventListener('dblclick', onUsedCardDblClick);
    usedCardsArea.appendChild(card);
  }

  renderDeckStatus();
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length){
    renderPlayerCircle(latestPlayers);
  }
  renderDeckStatus();
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl){
  inputCode.value = roomFromUrl;
}

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || 'åç„¡ã—';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  if (state.seatedTable === null) {
    await renderSeatTabs();
    seatPop.classList.remove('hidden');
  } else {
    seatPop.classList.add('hidden');
  }

  subscribePlayers();
  subscribeHostState();
  subscribeHands();
  subscribeGameStarted();
  subscribeDice();
  subscribeUsedCards();
  subscribeDiscardPile();
  subscribeTurnState();
  subscribeCubes();

  renderDeckStatus();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'ã‚³ãƒ”ãƒ¼å®Œäº†';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='ãƒªãƒ³ã‚¯ã‚³ãƒ”ãƒ¼';
    },1500);
  } catch {
    prompt('ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„', url);
  }
});

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;
  try{
    seatTabs.innerHTML = '';
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || 8;

    if(state.isHost && !roomData.maxPlayers){
      seatLabel.textContent = 'äººæ•°ã‚’é¸æŠ';
      for(let i=2;i<=8;i++){
        const tab = document.createElement('div');
        tab.className='tab';
        tab.textContent=i;
        tab.onclick = async () => {
          await update(roomRef,{maxPlayers:i});
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef,{playerId:state.userId,playerName:state.userName});
          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
    }else{
      seatLabel.textContent = 'å¸­ã‚’é¸æŠ';
      const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
      const tables = tablesSnap.val() || {};
      for(let i=1;i<=maxPlayers;i++){
        const tab = document.createElement('div');
        tab.className='tab';
        tab.textContent=i;
        const t = tables[i];
        if(t && t.playerId) tab.classList.add('disabled');
        tab.onclick = async () => {
          if(tab.classList.contains('disabled')) return;
          const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
          await set(tRef,{playerId:state.userId,playerName:state.userName});
          tab.classList.add('disabled');
          state.seatedTable = i;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
    }
  }finally{
    isRenderingSeatTabs=false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex,t]) => (t && t.playerId ? {
        id:t.playerId,
        name:t.playerName||'åç„¡ã—',
        seatIndex:Number(seatIndex)
      }:null))
      .filter(Boolean)
      .sort((a,b)=>a.seatIndex-b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p=>p.id===state.userId);
    if(mySeat && state.seatedTable===null){
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p=>p.id===state.userId);
    if(!meStillSeated && state.seatedTable!==null){
      state.seatedTable = null;
      await renderSeatTabs();
      seatPop.classList.remove('hidden');
    }

    renderPlayerCircle(players);
  });
}

function renderPlayerCircle(players){
  if(!playerCircle) return;

  const diceEl = diceArea;
  playerCircle.innerHTML = '';
  if (diceEl) playerCircle.appendChild(diceEl);

  if(!players.length) return;

  const n = players.length;
  const radius = 45;
  const step = (2*Math.PI)/n;
  const anchorAngle = Math.PI/2;
  const meIndex = players.findIndex(p=>p.id===state.userId);

  players.forEach((p,idx)=>{
    const k = (meIndex===-1)?idx: (idx-meIndex+n)%n;
    const angle = anchorAngle + step*k;
    const x = 50 + radius*Math.cos(angle);
    const y = 50 + radius*Math.sin(angle);

    const tag = document.createElement('div');

    const sideClass = (x < 50) ? 'side-left' : 'side-right';
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '') + ' ' + sideClass;

    tag.dataset.seatIndex = String(p.seatIndex);
    tag.dataset.playerId = p.id;

    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top  = `${y}%`;

    tag.onclick = () => {
      if(p.id===state.userId) return;
      if(!state.roomCode) return;
      if(state.seatedTable!==null) return;
      pendingSeatIndexToSteal = p.seatIndex;
      pendingPlayerNameToSteal = p.name;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `ã€Œ${p.name}ã€ã‚’è¿½ã„å‡ºã—ã¦ã€ã“ã®å¸­ã«ç€å¸­ã—ã¾ã™ã‹ï¼Ÿ`;
      kickDialog.classList.remove('hidden');
    };

    const handData = state.hands[p.id];
    if(p.id!==state.userId && handData && Array.isArray(handData.cards) && handData.cards.length){
      const miniHand = document.createElement('div');
      miniHand.className='mini-hand';
      const count = handData.cards.length;
      const spread = 70;
      const base = (count>1)?(-spread/2):0;
      handData.cards.forEach((v,idx2)=>{
        const card = document.createElement('div');
        card.className='mini-card';
        card.textContent='';
        const angleDeg = (count>1)? base + (spread/(count-1))*idx2 : 0;
        card.style.transform=`translate(-50%,0) rotate(${angleDeg}deg)`;
        card.style.zIndex=String(10+idx2);
        miniHand.appendChild(card);
      });
      tag.appendChild(miniHand);
    }

    playerCircle.appendChild(tag);
  });

  renderAttachedCubesForAllPlayers();
}

kickDialog.addEventListener('click',(e)=>{
  if(e.target===kickDialog){
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal=null;
    pendingPlayerNameToSteal=null;
    pendingSeatPlayerIdToSteal=null;
  }
});
btnKickNo.addEventListener('click',(e)=>{
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal=null;
  pendingPlayerNameToSteal=null;
  pendingSeatPlayerIdToSteal=null;
});

btnKickYes.addEventListener('click',async(e)=>{
  e.stopPropagation();
  if(pendingSeatIndexToSteal==null || !state.roomCode){
    kickDialog.classList.add('hidden');
    return;
  }
  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef,{playerId:state.userId,playerName:state.userName||'åç„¡ã—'});

  if(roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId===pendingSeatPlayerIdToSteal){
    await update(roomRef,{hostId:state.userId});
  }

  if (pendingSeatPlayerIdToSteal) {
    const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
    const handsSnap = await get(handsRef);
    const hands = handsSnap.val() || {};
    const victimId = pendingSeatPlayerIdToSteal;
    const victimHand = hands[victimId];
    const myHand = hands[state.userId];

    if (victimHand && Array.isArray(victimHand.cards) && victimHand.cards.length) {
      const myCards = (myHand && Array.isArray(myHand.cards)) ? myHand.cards : [];
      const newCards = [...myCards, ...victimHand.cards];

      await set(ref(db, `rooms/${state.roomCode}/hands/${state.userId}`), { cards: newCards });
      await set(ref(db, `rooms/${state.roomCode}/hands/${victimId}`), null);
    }
  }

  state.seatedTable = seatIndex;
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal=null;
  pendingPlayerNameToSteal=null;
  pendingSeatPlayerIdToSteal=null;
  seatPop.classList.add('hidden');
});

/* æ‰‹æœ­ä½¿ç”¨ãƒãƒƒãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã«å‡ºã™ï¼ˆã€Œä½¿ã†ã€ã ã‘ï¼‰ */
function onMyCardClick(e){
  if (state.usedCards && state.usedCards.length > 0) {
    return;
  }

  const cardEl = e.currentTarget;
  const idx = Number(cardEl.dataset.index || '-1');
  const value = cardEl.dataset.value || '';
  if (idx < 0 || !value) return;

  pendingUseCardIndex = idx;
  pendingUseCardValue = value;

  const clientX = e.clientX;
  const clientY = e.clientY;

  showUseCardDialogAt(clientX, clientY);
}

btnUseCardYes.addEventListener('click', async (e)=>{
  e.stopPropagation();
  await confirmUseCardUse();
});

function closeUseCardDialog(){
  useCardDialog.classList.add('hidden');
  pendingUseCardIndex = null;
  pendingUseCardValue = null;
}

function showUseCardDialogAt(clientX, clientY){
  if (!useCardDialog) return;

  useCardDialog.classList.remove('hidden');
  useCardDialog.style.left = '0px';
  useCardDialog.style.top  = '0px';

  const rect = useCardDialog.getBoundingClientRect();
  const margin = 8;

  let x = clientX - rect.width / 2;
  let y = clientY - rect.height - margin;

  if (x < margin) x = margin;
  if (x + rect.width > window.innerWidth - margin) {
    x = window.innerWidth - rect.width - margin;
  }

  if (y < margin) {
    y = clientY + margin;
    if (y + rect.height > window.innerHeight - margin) {
      y = window.innerHeight - rect.height - margin;
    }
  }

  useCardDialog.style.left = x + 'px';
  useCardDialog.style.top  = y + 'px';
}

async function confirmUseCardUse(){
  if(pendingUseCardIndex == null || !state.roomCode) {
    closeUseCardDialog();
    return;
  }
  const myId = state.userId;
  const handData = state.hands[myId];
  if(!handData || !Array.isArray(handData.cards)) {
    closeUseCardDialog();
    return;
  }
  const cards = [...handData.cards];
  if(pendingUseCardIndex < 0 || pendingUseCardIndex >= cards.length){
    closeUseCardDialog();
    return;
  }
  const value = cards[pendingUseCardIndex];

  cards.splice(pendingUseCardIndex,1);
  try{
    await set(ref(db, `rooms/${state.roomCode}/hands/${myId}/cards`), cards);
  }catch(err){
    console.error('update hand error', err);
  }

  try{
    const usedRef = ref(db, `rooms/${state.roomCode}/usedCards`);
    const next = [{
      value,
      ownerId: myId,
      usedAt: Date.now()
    }];
    await set(usedRef, next);
  }catch(err){
    console.error('update usedCards error', err);
  }

  closeUseCardDialog();
}

async function onUsedCardDblClick(){
  if (!state.roomCode) return;
  if (!state.usedCards || !state.usedCards.length) return;

  if (isMovingUsedCardToDiscard) return;
  isMovingUsedCardToDiscard = true;

  const last = state.usedCards[state.usedCards.length - 1];

  state.usedCards = [];
  renderUsedCards();

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const discRef = ref(db, `rooms/${state.roomCode}/discardPile`);

  try{
    const discSnap = await get(discRef);
    let discArr = discSnap.val() || [];
    if (!Array.isArray(discArr)) discArr = [];
    discArr.push(last);

    await update(roomRef, {
      discardPile: discArr,
      usedCards: []
    });

  }catch(err){
    console.error('move to discardPile error', err);
    state.usedCards = [last];
    renderUsedCards();
  }finally{
    isMovingUsedCardToDiscard = false;
  }
}

function clampToInner(x,y){
  const dist = Math.hypot(x,y);
  if(dist > INNER_RADIUS){
    const k = INNER_RADIUS / dist;
    x *= k;
    y *= k;
  }
  return {x,y};
}
function isInsideOuterByPos(x,y){
  return Math.hypot(x,y) <= OUTER_RADIUS;
}
function isDieActive(die){
  const tx = parseFloat(die.dataset.tx || '0');
  const ty = parseFloat(die.dataset.ty || '0');
  return isInsideOuterByPos(tx,ty);
}
function setDiePosition(die,x,y){
  die.dataset.tx = String(x);
  die.dataset.ty = String(y);
  die.style.setProperty('--tx', x+'px');
  die.style.setProperty('--ty', y+'px');
}

function getMiniCardObstacles(){
  const obstacles = [];
  if (!diceArea) return obstacles;

  const diceRect = diceArea.getBoundingClientRect();
  const cx = diceRect.left + diceRect.width / 2;
  const cy = diceRect.top  + diceRect.height / 2;

  const miniHands = document.querySelectorAll('.player-tag .mini-hand');
  miniHands.forEach(hand => {
    const r = hand.getBoundingClientRect();
    const centerX = r.left + r.width  / 2;
    const centerY = r.top + r.height / 2;

    const x = centerX - cx;
    const y = centerY - cy;

    const radius = Math.hypot(r.width, r.height) / 2 + 10;
    obstacles.push({ x, y, radius });
  });

  return obstacles;
}

function updateDieFace(die, val){
  const patterns = {
    1:[3],
    2:[0,6],
    3:[0,3,6],
    4:[0,1,5,6],
    5:[0,1,3,5,6],
    6:[0,1,2,4,5,6]
  };

  const active = patterns[val] || [];
  const pips = die._pips || [];

  for (let i = 0; i < pips.length; i++) {
    const pip = pips[i];
    const on = active.includes(i);

    pip.style.opacity = on ? 1 : 0;
    pip.classList.remove('red');

    if (val === 1 && i === 3 && on) {
      pip.classList.add('red');
    }
  }
}

function syncDiceStatesToDB(){
  if(!state.roomCode || !diceArea) return;
  const diceEls = diceArea.querySelectorAll('.dice');
  if(!diceEls.length) return;

  const updates = {};
  const now = Date.now();
  diceEls.forEach(die => {
    const id = die.dataset.id;
    if(!id) return;
    const tx = parseFloat(die.dataset.tx || '0');
    const ty = parseFloat(die.dataset.ty || '0');
    const rot = parseFloat(die.dataset.rot || '0');
    const val = parseInt(die.dataset.value || '1',10) || 1;
    updates[id] = {
      tx, ty, rot, value: val,
      updatedBy: state.userId,
      updatedAt: now
    };
  });
  const diceRef = ref(db, `rooms/${state.roomCode}/dice`);
  update(diceRef, updates);
}

function resolveCollisions(anchorDie = null){
  if(!diceArea) return;

  const allDice = Array.from(diceArea.querySelectorAll('.dice'));
  const diceEls = allDice.filter(d => isDieActive(d));
  const n = diceEls.length;
  if(n<=1) return;

  const xs = new Array(n);
  const ys = new Array(n);
  let anchorIndex = -1;

  for(let i=0;i<n;i++){
    xs[i] = parseFloat(diceEls[i].dataset.tx || '0');
    ys[i] = parseFloat(diceEls[i].dataset.ty || '0');
    if(anchorDie && diceEls[i] === anchorDie){
      anchorIndex = i;
    }
  }

  const obstacles = getMiniCardObstacles();

  for(let iter=0; iter<8; iter++){
    let moved = false;

    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        let dx = xs[j]-xs[i];
        let dy = ys[j]-ys[i];
        let dist = Math.hypot(dx,dy);
        if(dist === 0){
          dx = (Math.random()-0.5)||0.01;
          dy = (Math.random()-0.5)||0.01;
          dist = Math.hypot(dx,dy);
        }
        if(dist < DICE_COLLIDE_DIST){
          const overlap = (DICE_COLLIDE_DIST - dist)/2;
          const nx = dx/dist;
          const ny = dy/dist;

          if(anchorIndex !== -1){
            if(i === anchorIndex){
              xs[j] += nx*overlap*2;
              ys[j] += ny*overlap*2;
              ({x:xs[j],y:ys[j]} = clampToInner(xs[j],ys[j]));
            }else if(j === anchorIndex){
              xs[i] -= nx*overlap*2;
              ys[i] -= ny*overlap*2;
              ({x:xs[i],y:ys[i]} = clampToInner(xs[i],ys[i]));
            }else{
              xs[i] -= nx*overlap;
              ys[i] -= ny*overlap;
              xs[j] += nx*overlap;
              ys[j] += ny*overlap;
              ({x:xs[i],y:ys[i]} = clampToInner(xs[i],ys[i]));
              ({x:xs[j],y:ys[j]} = clampToInner(xs[j],ys[j]));
            }
          }else{
            xs[i] -= nx*overlap;
            ys[i] -= ny*overlap;
            xs[j] += nx*overlap;
            ys[j] += ny*overlap;
            ({x:xs[i],y:ys[i]} = clampToInner(xs[i],ys[i]));
            ({x:xs[j],y:ys[j]} = clampToInner(xs[j],ys[j]));
          }
          moved = true;
        }
      }
    }

    for(let i=0;i<n;i++){
      let x = xs[i];
      let y = ys[i];

      obstacles.forEach(ob => {
        let dx = x - ob.x;
        let dy = y - ob.y;
        let dist = Math.hypot(dx,dy);
        if(dist === 0){
          dx = 1;
          dy = 0;
          dist = 1;
        }

        const minDist = ob.radius + DICE_COLLIDE_DIST / 2;
        if(dist < minDist){
          const overlap = (minDist - dist);
          const nx = dx / dist;
          const ny = dy / dist;
          x += nx * overlap;
          y += ny * overlap;
          ({x,y} = clampToInner(x,y));
          moved = true;
        }
      });

      xs[i] = x;
      ys[i] = y;
    }

    if(!moved) break;
  }

  for(let i=0;i<n;i++){
    if(anchorIndex !== -1 && i === anchorIndex) continue;
    setDiePosition(diceEls[i], xs[i], ys[i]);
  }
}

function rollDie(die){
  if(!die) return;
  if(die.classList.contains('rolling')) return;
  die.classList.add('rolling');

  const baseRot = parseFloat(die.dataset.rot || '0');
  const extraRot = 360*2 + Math.floor(Math.random()*360);
  const targetRot = baseRot + extraRot;
  die.dataset.rot = String(targetRot);
  die.style.setProperty('--rot', targetRot + 'deg');

  setTimeout(()=>{
    const val = Math.floor(Math.random()*6)+1;
    die.dataset.value = String(val);
    updateDieFace(die,val);
    die.classList.remove('rolling');

    if (isDieActive(die)) {
      resolveCollisions();
    }
    syncDiceStatesToDB();
  },500);
}

function showDiceAdjustPopup(die){
  if(!diceAdjustPop || !die) return;
  diceAdjustPop.dataset.targetDieId = die.dataset.id || '';

  const rect = die.getBoundingClientRect();
  const popWidth = 160;
  const popHeight = 44;

  let left = rect.left + rect.width / 2 - popWidth / 2;
  let top  = rect.top  - popHeight - 8;

  diceAdjustPop.style.left = left + 'px';
  diceAdjustPop.style.top  = top  + 'px';
  diceAdjustPop.classList.remove('hidden');
}

function hideDiceAdjustPopup(){
  if(!diceAdjustPop) return;
  diceAdjustPop.classList.add('hidden');
  diceAdjustPop.dataset.targetDieId = '';
}

if(diceAdjustPop){
  diceAdjustPop.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if(!btn) return;

    const setVal = parseInt(btn.dataset.value || '1', 10);
    if(!Number.isFinite(setVal) || setVal < 1 || setVal > 6) return;

    const dieId = diceAdjustPop.dataset.targetDieId;
    if(!dieId || !diceArea) return;

    const die = diceArea.querySelector(`.dice[data-id="${dieId}"]`);
    if(!die) return;

    die.dataset.value = String(setVal);
    updateDieFace(die, setVal);
    syncDiceStatesToDB();

    hideDiceAdjustPopup();
  });

  document.addEventListener('click', (e) => {
    if(diceAdjustPop.classList.contains('hidden')) return;
    if(e.target.closest('#diceAdjustPop')) return;
    if(e.target.closest('.dice')) return;
    hideDiceAdjustPopup();
  });
}

function onDicePointerDown(e){
  const die = e.currentTarget;
  if(diceLocked) return;
  if(die.classList.contains('rolling')) return;

  draggingDie = die;
  dragPointerId = e.pointerId;

  startTx = parseFloat(die.dataset.tx || '0');
  startTy = parseFloat(die.dataset.ty || '0');
  dragStartX = e.clientX;
  dragStartY = e.clientY;

  triggeredDiceThisDrag = new Set();
  allDiceRolledThisDrag = false;

  longPressTriggered = false;
  clearLongPressTimer();
  longPressTimer = setTimeout(() => {
    if(!draggingDie || draggingDie !== die) return;
    longPressTriggered = true;
    die.classList.remove('dragging');
    showDiceAdjustPopup(die);
  }, LONG_PRESS_MS);

  die.classList.add('dragging');
  die.setPointerCapture(dragPointerId);
}

function onDicePointerMove(e){
  if(!draggingDie || e.pointerId !== dragPointerId) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;

  if(!longPressTriggered && longPressTimer){
    if(Math.abs(dx) > LONG_PRESS_MOVE_TOL || Math.abs(dy) > LONG_PRESS_MOVE_TOL){
      clearLongPressTimer();
    }
  }

  if(longPressTriggered){
    return;
  }

  let x = startTx + dx;
  let y = startTy + dy;

  const insideOuter = isInsideOuterByPos(x,y);
  if (insideOuter) {
    ({x,y} = clampToInner(x,y));
  }
  setDiePosition(draggingDie,x,y);

  if (insideOuter) {
    resolveCollisions(draggingDie);
  }

  if (diceArea && triggeredDiceThisDrag && insideOuter && canTriggerContactRoll()) {
    const diceEls = diceArea.querySelectorAll('.dice');
    const myTx = x;
    const myTy = y;

    diceEls.forEach(other => {
      if (other === draggingDie) return;
      if (!isDieActive(other)) return;
      const id = other.dataset.id;
      if (!id || triggeredDiceThisDrag.has(id)) return;

      const ox = parseFloat(other.dataset.tx || '0');
      const oy = parseFloat(other.dataset.ty || '0');
      const dist = Math.hypot(ox - myTx, oy - myTy);

      if (dist < DICE_CONTACT_DIST) {
        triggeredDiceThisDrag.add(id);
        rollDie(other);
      }
    });

    if (!allDiceRolledThisDrag && triggeredDiceThisDrag.size >= 1) {
      allDiceRolledThisDrag = true;
      const diceEls2 = diceArea.querySelectorAll('.dice');
      diceEls2.forEach(d => {
        if (isDieActive(d)) {
          rollDie(d);
        }
      });
    }
  }

  syncDiceStatesToDB();
}

function onDicePointerUp(e){
  if(!draggingDie || e.pointerId !== dragPointerId) return;
  const die = draggingDie;

  clearLongPressTimer();
  const wasLong = longPressTriggered;
  longPressTriggered = false;

  die.classList.remove('dragging');
  try{ die.releasePointerCapture(dragPointerId); }catch{}

  draggingDie = null;
  dragPointerId = null;

  triggeredDiceThisDrag = null;
  allDiceRolledThisDrag = false;

  if(wasLong){
    syncDiceStatesToDB();
    return;
  }

  syncDiceStatesToDB();
  rollDie(die);
}

window.addEventListener('pointermove', onDicePointerMove);
window.addEventListener('pointerup', onDicePointerUp);
window.addEventListener('pointercancel', onDicePointerUp);

function ensureDiceArea(){
  if(diceArea) return;
  if(!playerCircle) return;

  diceArea = document.createElement('div');
  diceArea.id = 'diceArea';
  diceArea.className = 'dice-area';
  playerCircle.appendChild(diceArea);
}

function subscribeDice(){
  if(!state.roomCode) return;
  const diceRef = ref(db, `rooms/${state.roomCode}/dice`);
  onValue(diceRef, snap => {
    const data = snap.val();
    if(!data) return;
    ensureDiceArea();
    renderDiceFromState(data);
  });
}

function renderDiceFromState(diceData){
  if(!diceArea) return;

  const existing = new Map();
  diceArea.querySelectorAll('.dice').forEach(die=>{
    existing.set(die.dataset.id, die);
  });

  Object.entries(diceData).forEach(([id,info])=>{
    if(!info) return;
    let die = existing.get(id);
    if(!die){
      die = document.createElement('div');
      die.className='dice';
      die.dataset.id = id;
      die.dataset.tx='0';
      die.dataset.ty='0';
      die.dataset.rot='0';

      const face = document.createElement('div');
      face.className='dice-face';
      const pips=[];
      for(let k=0;k<7;k++){
        const pip = document.createElement('div');
        pip.className='pip pos'+k;
        face.appendChild(pip);
        pips.push(pip);
      }
      die._pips = pips;
      die.appendChild(face);

      die.addEventListener('pointerdown', onDicePointerDown);
      if(diceLocked) die.classList.add('dice-locked');
      diceArea.appendChild(die);
    }
    existing.delete(id);

    const isDraggingMine = die.classList.contains('dragging') && info.updatedBy === state.userId;
    if(isDraggingMine) return;

    let tx = Number(info.tx)||0;
    let ty = Number(info.ty)||0;
    const rot = Number(info.rot)||0;
    const val = Number(info.value)||1;

    die.dataset.tx = String(tx);
    die.dataset.ty = String(ty);
    die.dataset.rot = String(rot);
    die.dataset.value = String(val);
    die.style.setProperty('--rot', rot+'deg');

    if (isInsideOuterByPos(tx,ty)) {
      ({x:tx,y:ty} = clampToInner(tx,ty));
      die.dataset.tx = String(tx);
      die.dataset.ty = String(ty);
    }

    setDiePosition(die, tx, ty);
    updateDieFace(die, val);
  });

  for(const die of existing.values()){
    die.remove();
  }
}

async function initDiceState(){
  if(!state.roomCode) return;
  const diceObj = {};
  for(let i=0;i<8;i++){
    const r = INNER_RADIUS * Math.sqrt(Math.random());
    const angle = Math.random()*2*Math.PI;
    const x = r*Math.cos(angle);
    const y = r*Math.sin(angle);
    const val = Math.floor(Math.random()*6)+1;
    diceObj[i] = {
      tx:x,
      ty:y,
      rot:0,
      value:val,
      updatedBy:state.userId,
      updatedAt:Date.now()
    };
  }
  await set(ref(db, `rooms/${state.roomCode}/dice`), diceObj);
}

function playTurnBanner(playerName){
  if(!turnBanner) return;
  if(!playerName) return;
  if(turnBannerRunning) return;
  turnBannerRunning = true;

  setDiceLocked(true);

  turnBanner.textContent = `ã€Œ${playerName}ã€ã®ã‚¿ãƒ¼ãƒ³`;
  turnBanner.classList.remove('hidden','turn-banner-center','turn-banner-right');

  void turnBanner.offsetWidth;
  const slideMs = 600;
  const holdMs = 2000;

  turnBanner.classList.add('turn-banner-center');

  setTimeout(() => {
    setTimeout(() => {
      turnBanner.classList.add('turn-banner-right');
      setTimeout(() => {
        turnBanner.classList.add('hidden');
        turnBanner.classList.remove('turn-banner-center','turn-banner-right');
        setDiceLocked(false);
        turnBannerRunning = false;
      }, slideMs);
    }, holdMs);
  }, slideMs);
}

function renderTurnSelectPop(){
  if(!turnSelectList) return;
  turnSelectList.innerHTML = '';
  if(!latestPlayers.length) return;

  latestPlayers.forEach(p=>{
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.textContent = `å¸­${p.seatIndex}: ${p.name}`;
    btn.onclick = async () => {
      if(!state.roomCode || !state.isHost) return;
      const tRef = ref(db, `rooms/${state.roomCode}/turnState`);
      await set(tRef, {
        seatIndex: p.seatIndex,
        playerId: p.id,
        playerName: p.name,
        startedAt: Date.now()
      });
      hideTurnSelectPop();
    };
    turnSelectList.appendChild(btn);
  });
}
function showTurnSelectPop(){
  if(!turnSelectPop) return;
  if(!state.isHost) return;
  if(!latestPlayers.length) return;
  renderTurnSelectPop();
  turnSelectPop.classList.remove('hidden');
}
function hideTurnSelectPop(){
  if(!turnSelectPop) return;
  turnSelectPop.classList.add('hidden');
}

document.addEventListener('click', (e)=>{
  if(!turnSelectPop || turnSelectPop.classList.contains('hidden')) return;
  if(e.target.closest('#turnSelectPop')) return;
  if(e.target === turnNextBtn || e.target.closest('#turnNextBtn')) return;
  hideTurnSelectPop();
});

hostSettingsBtn.addEventListener('click',()=>{
  if(!state.isHost) return;
  const isHidden = startPop.classList.contains('hidden');
  if(isHidden) startPop.classList.remove('hidden');
  else startPop.classList.add('hidden');
});
btnStartPopClose.addEventListener('click',()=> startPop.classList.add('hidden'));

btnGameStart.addEventListener('click', async ()=>{
  if(!state.isHost) return;
  await dealInitialHands();
  await initDiceState();
  await initCubeState();
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  await update(roomRef,{gameStarted: Date.now()});
  startPop.classList.add('hidden');
});

/* â˜…â˜…â˜… ã“ã“ãŒä¿®æ­£ãƒã‚¤ãƒ³ãƒˆï¼šæ¯å› DB ã‹ã‚‰æœ€æ–° turnState ã‚’èª­ã‚€ â˜…â˜…â˜… */
async function advanceTurnToNext(){
  if(!state.isHost) return;
  if(!state.roomCode) return;
  if(!latestPlayers.length) return;

  let currentSeat = null;
  try {
    const turnSnap = await get(ref(db, `rooms/${state.roomCode}/turnState`));
    const turnVal = turnSnap.val();
    if (turnVal && typeof turnVal.seatIndex === 'number') {
      currentSeat = turnVal.seatIndex;
      state.currentTurnSeat = currentSeat;
    }
  } catch (err) {
    console.error('read turnState error', err);
  }

  let nextSeatIndex = null;
  const sorted = [...latestPlayers].sort((a,b)=>a.seatIndex - b.seatIndex);

  if(currentSeat == null){
    nextSeatIndex = sorted[0].seatIndex;
  } else {
    const idx = sorted.findIndex(p => p.seatIndex === currentSeat);
    if(idx === -1){
      const after = sorted.find(p => p.seatIndex > currentSeat);
      nextSeatIndex = after ? after.seatIndex : sorted[0].seatIndex;
    }else{
      const nextPlayer = sorted[(idx + 1) % sorted.length];
      nextSeatIndex = nextPlayer.seatIndex;
    }
  }

  const nextPlayer = latestPlayers.find(p => p.seatIndex === nextSeatIndex);
  if(!nextPlayer) return;

  const tRef = ref(db, `rooms/${state.roomCode}/turnState`);
  await set(tRef, {
    seatIndex: nextSeatIndex,
    playerId: nextPlayer.id,
    playerName: nextPlayer.name,
    startedAt: Date.now()
  });
}

/* â–·é•·æŠ¼ã—ã®å®Ÿè£… */
if(turnNextBtn){
  turnNextBtn.addEventListener('pointerdown', (e)=>{
    if(!state.isHost) return;
    turnBtnPointerId = e.pointerId;
    turnBtnDownX = e.clientX;
    turnBtnDownY = e.clientY;
    turnBtnLongPressTriggered = false;
    clearTurnBtnLongPressTimer();
    turnBtnLongPressTimer = setTimeout(()=>{
      turnBtnLongPressTriggered = true;
      suppressTurnClick = true;
      showTurnSelectPop();
    }, LONG_PRESS_MS);
    turnNextBtn.setPointerCapture(turnBtnPointerId);
  });

  turnNextBtn.addEventListener('pointermove', (e)=>{
    if(turnBtnPointerId == null || e.pointerId !== turnBtnPointerId) return;
    if(!turnBtnLongPressTimer) return;
    const dx = e.clientX - turnBtnDownX;
    const dy = e.clientY - turnBtnDownY;
    if(Math.abs(dx) > LONG_PRESS_MOVE_TOL || Math.abs(dy) > LONG_PRESS_MOVE_TOL){
      clearTurnBtnLongPressTimer();
    }
  });

  const endTurnBtnPointer = (e)=>{
    if(turnBtnPointerId == null || e.pointerId !== turnBtnPointerId) return;
    clearTurnBtnLongPressTimer();
    try{ turnNextBtn.releasePointerCapture(turnBtnPointerId); }catch{}
    turnBtnPointerId = null;
  };
  turnNextBtn.addEventListener('pointerup', endTurnBtnPointer);
  turnNextBtn.addEventListener('pointercancel', endTurnBtnPointer);

  turnNextBtn.addEventListener('click', async (e)=>{
    if(!state.isHost) return;
    if(suppressTurnClick){
      suppressTurnClick = false;
      return;
    }
    await advanceTurnToNext();
  });
}

/* é–‹å§‹æ™‚ã®é…ã‚Šæ–¹ï¼šCARD_POOLã‹ã‚‰é‡è¤‡ãªã—ã§é…ã‚‹ */
async function dealInitialHands(){
  if(!state.roomCode) return;
  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const deck = [...CARD_POOL];

  function drawCard(){
    if(deck.length === 0) return null;
    const idx = Math.floor(Math.random() * deck.length);
    const [cardId] = deck.splice(idx, 1);
    return cardId;
  }

  const hands = {};
  for(const seatIndex of Object.keys(tables)){
    const t = tables[seatIndex];
    if(!t || !t.playerId) continue;

    const cards = [];
    for(let i=0;i<5;i++){
      const c = drawCard();
      if(!c) break;
      cards.push(c);
    }
    hands[t.playerId] = { cards };
  }

  await set(ref(db, `rooms/${state.roomCode}/hands`), hands);
}

/* æ‰‹æœ­ãƒãƒƒãƒ—ï¼šå¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹ */
document.addEventListener('click', (e)=>{
  if (!useCardDialog || useCardDialog.classList.contains('hidden')) return;
  if (e.target.closest('#useCardDialog')) return;
  if (e.target.closest('.my-card')) return;
  closeUseCardDialog();
});

/* â˜…â˜…â˜… ã“ã“ã‹ã‚‰å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–å‡¦ç† â˜…â˜…â˜… */

function ensureCubeArea(){
  if(cubeArea) return;
  cubeArea = document.createElement('div');
  cubeArea.id = 'cubeArea';
  cubeArea.className = 'cube-circle';
  document.body.appendChild(cubeArea);
}

/* åŠå¾„ã§ã‚¯ãƒ©ãƒ³ãƒ—ã™ã‚‹æ±ç”¨é–¢æ•°ï¼ˆã‚­ãƒ¥ãƒ¼ãƒ–ç”¨ï¼‰ */
function clampToRadius(x,y,radius){
  const dist = Math.hypot(x,y);
  if(dist > radius){
    const k = radius/dist;
    x *= k;
    y *= k;
  }
  return {x,y};
}

function setCubePosition(el,x,y){
  el.dataset.tx = String(x);
  el.dataset.ty = String(y);
  el.style.setProperty('--tx', x + 'px');
  el.style.setProperty('--ty', y + 'px');
}

/* ã‚­ãƒ¥ãƒ¼ãƒ–çŠ¶æ…‹ã‚’DBã«åŒæœŸï¼ˆå³ä¸Šå††ã®ä¸­ã«ã‚ã‚‹ã‚‚ã®ã ã‘ï¼‰ */
function syncCubesToDB(){
  if(!state.roomCode || !cubeArea) return;
  const cubes = cubeArea.querySelectorAll('.cube-piece:not(.attached-hidden)');
  if(!cubes.length) return;
  const updates = {};
  const now = Date.now();
  cubes.forEach(c => {
    const id = c.dataset.id;
    if(!id) return;
    const tx = parseFloat(c.dataset.tx || '0');
    const ty = parseFloat(c.dataset.ty || '0');
    updates[id] = {
      tx, ty,
      updatedBy: state.userId,
      updatedAt: now
    };
  });
  const cubesRef = ref(db, `rooms/${state.roomCode}/cubes`);
  update(cubesRef, updates);
}

/* å††å†…ã®ã‚­ãƒ¥ãƒ¼ãƒ–åŒå£«ã®è¡çªè§£æ¶ˆï¼ˆå³ä¸Šå††ç”¨ï¼‰ */
function resolveCubeCollisions(anchorCube = null){
  if(!cubeArea) return;
  const all = Array.from(cubeArea.querySelectorAll('.cube-piece'));
  const cubes = all.filter(c => !c.classList.contains('attached-hidden'));
  const n = cubes.length;
  if(n <= 1) return;

  const xs = new Array(n);
  const ys = new Array(n);
  let anchorIndex = -1;

  for(let i=0;i<n;i++){
    xs[i] = parseFloat(cubes[i].dataset.tx || '0');
    ys[i] = parseFloat(cubes[i].dataset.ty || '0');
    if(anchorCube && cubes[i] === anchorCube){
      anchorIndex = i;
    }
  }

  for(let iter=0; iter<8; iter++){
    let moved = false;
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        let dx = xs[j] - xs[i];
        let dy = ys[j] - ys[i];
        let dist = Math.hypot(dx,dy);
        if(dist === 0){
          dx = (Math.random()-0.5)||0.01;
          dy = (Math.random()-0.5)||0.01;
          dist = Math.hypot(dx,dy);
        }
        if(dist < CUBE_COLLIDE_DIST){
          const overlap = (CUBE_COLLIDE_DIST - dist)/2;
          const nx = dx/dist;
          const ny = dy/dist;

          if(anchorIndex !== -1){
            if(i === anchorIndex){
              xs[j] += nx*overlap*2;
              ys[j] += ny*overlap*2;
              ({x:xs[j],y:ys[j]} = clampToRadius(xs[j],ys[j], CUBE_INNER_RADIUS));
            }else if(j === anchorIndex){
              xs[i] -= nx*overlap*2;
              ys[i] -= ny*overlap*2;
              ({x:xs[i],y:ys[i]} = clampToRadius(xs[i],ys[i], CUBE_INNER_RADIUS));
            }else{
              xs[i] -= nx*overlap;
              ys[i] -= ny*overlap;
              xs[j] += nx*overlap;
              ys[j] += ny*overlap;
              ({x:xs[i],y:ys[i]} = clampToRadius(xs[i],ys[i], CUBE_INNER_RADIUS));
              ({x:xs[j],y:ys[j]} = clampToRadius(xs[j],ys[j], CUBE_INNER_RADIUS));
            }
          }else{
            xs[i] -= nx*overlap;
            ys[i] -= ny*overlap;
            xs[j] += nx*overlap;
            ys[j] += ny*overlap;
            ({x:xs[i],y:ys[i]} = clampToRadius(xs[i],ys[i], CUBE_INNER_RADIUS));
            ({x:xs[j],y:ys[j]} = clampToRadius(xs[j],ys[j], CUBE_INNER_RADIUS));
          }
          moved = true;
        }
      }
    }
    if(!moved) break;
  }

  for(let i=0;i<n;i++){
    if(anchorIndex !== -1 && i === anchorIndex) continue;
    setCubePosition(cubes[i], xs[i], ys[i]);
  }
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ä¸­å¿ƒã®ã©ã‚Œã‹ã®å††ï¼ˆåŠå¾„35pxï¼‰ã«å…¥ã£ã¦ã„ã‚‹ã‹åˆ¤å®š */
function findSeatByPoint(clientX, clientY){
  const tags = document.querySelectorAll('.player-tag');
  let bestSeat = null;
  let bestDist = Infinity;
  const R = 35;

  tags.forEach(tag => {
    const seatIndex = Number(tag.dataset.seatIndex || '-1');
    if(seatIndex < 0) return;
    const rect = tag.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = clientX - cx;
    const dy = clientY - cy;
    const dist = Math.hypot(dx,dy);
    if(dist <= R && dist < bestDist){
      bestDist = dist;
      bestSeat = seatIndex;
    }
  });

  return bestSeat;
}

/* ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’æŒ‡å®šå¸­ã®ãƒãƒ¼ãƒ ã‚¿ã‚°ã«ã‚¢ã‚¿ãƒƒãƒ */
async function attachCubeToSeat(cubeEl, seatIndex){
  if(!state.roomCode) return;
  if(seatIndex == null) return;
  const cubeId = cubeEl.dataset.id;
  if(!cubeId) return;

  const cubeRef = ref(db, `rooms/${state.roomCode}/cubes/${cubeId}`);
  const snap = await get(cubeRef);
  const cur = snap.val() || {};
  cur.attachedSeat = seatIndex;
  cur.updatedBy = state.userId;
  cur.updatedAt = Date.now();
  await set(cubeRef, cur);
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ã‹ã‚‰20pxä»¥ä¸Šãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸã‚­ãƒ¥ãƒ¼ãƒ–ã‚’å††ã«æˆ»ã™ */
async function detachCubeFromSeat(cubeId){
  if(!state.roomCode || !cubeId) return;
  const cubesRef = ref(db, `rooms/${state.roomCode}/cubes`);
  const snap = await get(cubesRef);
  const cubes = snap.val() || {};
  const cube = cubes[cubeId];
  if(!cube) return;

  const usedPositions = [];
  Object.entries(cubes).forEach(([id,c])=>{
    if(!c || id === cubeId) return;
    if(c.attachedSeat) return;
    const x = Number(c.tx)||0;
    const y = Number(c.ty)||0;
    usedPositions.push({x,y});
  });

  function randomPos(){
    for(let attempt=0; attempt<50; attempt++){
      const r = CUBE_INNER_RADIUS * Math.sqrt(Math.random());
      const ang = Math.random()*2*Math.PI;
      let x = r*Math.cos(ang);
      let y = r*Math.sin(ang);
      let ok = true;
      for(const p of usedPositions){
        if(Math.hypot(p.x-x,p.y-y) < CUBE_COLLIDE_DIST){
          ok = false;
          break;
        }
      }
      if(ok){
        usedPositions.push({x,y});
        return {x,y};
      }
    }
    return {x:0,y:0};
  }

  const pos = randomPos();
  cube.tx = pos.x;
  cube.ty = pos.y;
  cube.attachedSeat = null;
  cube.updatedBy = state.userId;
  cube.updatedAt = Date.now();

  const updates = {};
  updates[cubeId] = cube;
  await update(cubesRef, updates);
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°å³å´ã«ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’æç”»ã™ã‚‹ï¼ˆside-left/side-rightå¯¾å¿œï¼‰ */
function renderAttachedCubesForAllPlayers(){
  if(!latestCubeData) return;
  const tags = document.querySelectorAll('.player-tag');
  if(!tags.length) return;

  tags.forEach(tag => {
    const seatIndex = Number(tag.dataset.seatIndex || '-1');
    if(seatIndex < 0) return;

    let row = tag.querySelector('.attached-cube-row');
    if(!row){
      row = document.createElement('div');
      row.className = 'attached-cube-row';
      row.dataset.seatIndex = String(seatIndex);
      tag.appendChild(row);
    }
    row.innerHTML = '';

    const cubesForSeat = Object.entries(latestCubeData)
      .filter(([id,info]) => info && info.attachedSeat === seatIndex)
      .sort((a,b) => (a[1].updatedAt || 0) - (b[1].updatedAt || 0));

    cubesForSeat.forEach(([id,info]) => {
      const cubeHolder = document.createElement('div');
      cubeHolder.className = 'attached-cube';
      cubeHolder.dataset.cubeId = id;
      cubeHolder.dataset.seatIndex = String(seatIndex);
      if(cubeTemplate){
        cubeHolder.appendChild(cubeTemplate.content.cloneNode(true));
      }
      cubeHolder.addEventListener('pointerdown', onAttachedCubePointerDown);
      row.appendChild(cubeHolder);
    });
  });
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ã«ä¸¦ã‚“ã§ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã®ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç† */
function onAttachedCubePointerDown(e){
  const el = e.currentTarget;
  attachedDragCube = el;
  attachedDragPointerId = e.pointerId;
  attachedDragSeatIndex = Number(el.dataset.seatIndex || '-1');
  attachedDragCubeId = el.dataset.cubeId || null;
  attachedDragStartX = e.clientX;
  attachedDragStartY = e.clientY;
  el.classList.add('dragging');
  el.style.transition = 'none';
  el.style.transform = 'translate(0,0)';
  el.setPointerCapture(attachedDragPointerId);
}

function onAttachedCubePointerMove(e){
  if(!attachedDragCube || e.pointerId !== attachedDragPointerId) return;
  const dx = e.clientX - attachedDragStartX;
  const dy = e.clientY - attachedDragStartY;
  attachedDragCube.style.transform = `translate(${dx}px, ${dy}px)`;
}

async function onAttachedCubePointerUp(e){
  if(!attachedDragCube || e.pointerId !== attachedDragPointerId) return;
  const el = attachedDragCube;
  try{ el.releasePointerCapture(attachedDragPointerId);}catch{}
  el.classList.remove('dragging');
  el.style.transition = 'transform .15s ease-out';

  const dx = e.clientX - attachedDragStartX;
  const dy = e.clientY - attachedDragStartY;
  const dist = Math.hypot(dx,dy);

  el.style.transform = 'translate(0,0)';

  const cubeId = attachedDragCubeId;
  attachedDragCube = null;
  attachedDragPointerId = null;
  attachedDragCubeId = null;
  attachedDragSeatIndex = null;
  attachedDragStartX = 0;
  attachedDragStartY = 0;

  if(dist > 80 && cubeId){
    await detachCubeFromSeat(cubeId);
  }
}

window.addEventListener('pointermove', onAttachedCubePointerMove);
window.addEventListener('pointerup', onAttachedCubePointerUp);
window.addEventListener('pointercancel', onAttachedCubePointerUp);

/* ã‚­ãƒ¥ãƒ¼ãƒ–å††å†…ãƒ‰ãƒ©ãƒƒã‚° */
function onCubePointerDown(e){
  if(!cubeArea) return;
  const cube = e.currentTarget;
  draggingCube = cube;
  cubePointerId = e.pointerId;

  cubeStartTx = parseFloat(cube.dataset.tx || '0');
  cubeStartTy = parseFloat(cube.dataset.ty || '0');
  cubeStartX = e.clientX;
  cubeStartY = e.clientY;

  cube.classList.add('dragging');
  cube.setPointerCapture(cubePointerId);
}

function onCubePointerMove(e){
  if(!draggingCube || e.pointerId !== cubePointerId) return;
  const dx = e.clientX - cubeStartX;
  const dy = e.clientY - cubeStartY;

  let x = cubeStartTx + dx;
  let y = cubeStartTy + dy;

  setCubePosition(draggingCube, x, y);

  if (isInsideCubeRadius(x, y)) {
    resolveCubeCollisions(draggingCube);
  }

  syncCubesToDB();
}

async function onCubePointerUp(e){
  if(!draggingCube || e.pointerId !== cubePointerId) return;
  const cube = draggingCube;

  try{ cube.releasePointerCapture(cubePointerId); }catch{}
  cube.classList.remove('dragging');
  draggingCube = null;
  cubePointerId = null;

  let tx = parseFloat(cube.dataset.tx || '0');
  let ty = parseFloat(cube.dataset.ty || '0');

  if (!isInsideCubeRadius(tx, ty)) {
    const clamped = clampToRadius(tx, ty, CUBE_INNER_RADIUS);
    setCubePosition(cube, clamped.x, clamped.y);
    resolveCubeCollisions(cube);
  }

  syncCubesToDB();

  const seatIndex = findSeatByPoint(e.clientX, e.clientY);
  if(seatIndex != null){
    await attachCubeToSeat(cube, seatIndex);
  }
}

window.addEventListener('pointermove', onCubePointerMove);
window.addEventListener('pointerup', onCubePointerUp);
window.addEventListener('pointercancel', onCubePointerUp);

function subscribeCubes(){
  if(!state.roomCode) return;
  const cubesRef = ref(db, `rooms/${state.roomCode}/cubes`);
  onValue(cubesRef, snap => {
    const data = snap.val() || {};
    latestCubeData = data;
    ensureCubeArea();
    renderCubesFromState(data);
    renderAttachedCubesForAllPlayers();
  });
}

/* å³ä¸Šå††ã®ã‚­ãƒ¥ãƒ¼ãƒ–æç”»ï¼ˆattachedSeat ãŒ null ã®ã‚‚ã®ã ã‘è¡¨ç¤ºï¼‰ */
function renderCubesFromState(cubeData){
  if(!cubeArea) return;

  const existing = new Map();
  cubeArea.querySelectorAll('.cube-piece').forEach(el => {
    existing.set(el.dataset.id, el);
  });

  Object.entries(cubeData).forEach(([id,info])=>{
    if(!info) return;
    let cube = existing.get(id);
    if(!cube){
      cube = document.createElement('div');
      cube.className = 'cube-piece';
      cube.dataset.id = id;
      cube.dataset.tx = '0';
      cube.dataset.ty = '0';
      if(cubeTemplate){
        const frag = cubeTemplate.content.cloneNode(true);
        cube.appendChild(frag);
      }
      cube.addEventListener('pointerdown', onCubePointerDown);
      cubeArea.appendChild(cube);
    }
    existing.delete(id);

    let tx = Number(info.tx) || 0;
    let ty = Number(info.ty) || 0;
    setCubePosition(cube, tx, ty);

    if(info.attachedSeat != null && info.attachedSeat !== undefined){
      cube.classList.add('attached-hidden');
      cube.style.display = 'none';
    }else{
      cube.classList.remove('attached-hidden');
      cube.style.display = '';
    }
  });

  for(const el of existing.values()){
    el.remove();
  }
}

/* å„å‚åŠ è€…ã«3å€‹ãšã¤ç«‹æ–¹ä½“ã‚’é…ç½® */
async function initCubeState(){
  if(!state.roomCode) return;
  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const cubes = {};
  const usedPositions = [];

  function randomPos(){
    for(let attempt=0; attempt<100; attempt++){
      const r = CUBE_INNER_RADIUS * Math.sqrt(Math.random());
      const angle = Math.random()*2*Math.PI;
      let x = r*Math.cos(angle);
      let y = r*Math.sin(angle);

      let ok = true;
      for(const p of usedPositions){
        const dist = Math.hypot(p.x - x, p.y - y);
        if(dist < CUBE_COLLIDE_DIST){
          ok = false;
          break;
        }
      }
      if(ok){
        usedPositions.push({x,y});
        return {x,y};
      }
    }
    return {x:0,y:0};
  }

  for(const [seatIndex, t] of Object.entries(tables)){
    if(!t || !t.playerId) continue;
    for(let i=0;i<3;i++){
      const pos = randomPos();
      const id = `${seatIndex}_${i}`;
      cubes[id] = {
        tx: pos.x,
        ty: pos.y,
        ownerSeat: Number(seatIndex),
        attachedSeat: null,
        updatedBy: state.userId,
        updatedAt: Date.now()
      };
    }
  }

  await set(ref(db, `rooms/${state.roomCode}/cubes`), cubes);
}

/* â˜…â˜…â˜… å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–å‡¦ç† ã“ã“ã¾ã§ â˜…â˜…â˜… */

</script>

</body>
</html>
